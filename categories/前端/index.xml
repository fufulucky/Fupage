<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on Yujie Fu</title>
    <link>https://fufulucky.github.io/Fupage.github.io/categories/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on Yujie Fu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Wed, 14 Aug 2019 22:57:24 +0800</lastBuildDate>
    
	<atom:link href="https://fufulucky.github.io/Fupage.github.io/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>组件之间使用v Model</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-08/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8v-model/</link>
      <pubDate>Wed, 14 Aug 2019 22:57:24 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-08/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8v-model/</guid>
      <description>h3{ color: lightseagreen; } .codes{ color: burlywood; } #buzou{ list-style: none; } 组件之间使用v-model v-model不仅仅是作为一个input中数据绑定的一种方法，他还可以在组件中使用v-model。 而事实上，v-model只是一个语法糖，它所包含的是：value=xxxx和@input=xxxx 例如在一个父组件中（写法一）： 父组件 《aa class=&amp;ldquo;abc&amp;rdquo; v-model=&amp;lsquo;test&amp;rsquo; 》《/aa》 子组件 子组件(写法二)</description>
    </item>
    
    <item>
      <title>Rollup学习</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-08/rollup%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 13 Aug 2019 23:14:59 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-08/rollup%E5%AD%A6%E4%B9%A0/</guid>
      <description>h3{ color: lightseagreen; } .codes span{ color: burlywood; } Rollup.js学习（一） 一、什么是Rollup.js Rollup.js是JavaScript的模块打包器，像是vue和react等框架都是通过rollup.js进行打包的。 二、第一个Rollup.js应用 1.安装rollup.js 全局安装：npm install rollup –global 2.创建一个简单的项目 首先来创建目录：mkdir src //在当前目录下创建src文件夹，接下来在src文件夹内创建一个</description>
    </item>
    
    <item>
      <title>ES6新特性</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-06/es6%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 25 Jun 2019 18:11:20 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-06/es6%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>ES6新特性（自己遇到的一些） 1. 使用let而不是var，避免变量覆盖问题，常量const,变量let常量。 Const很神奇，const定义的对象，当对象改变了之后，const定义的值也会跟着改变。cosnt定义的变量是一个对象的一个属性值，但是当对象属性值改变了以后，const定义的这个值并不会改变。 一句话总结，const定义的对象可以通过改变其属性值的方法，对它进行改变。而const定义的常量是</description>
    </item>
    
    <item>
      <title>Vue Computed和methods</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/vue-computed%E5%92%8Cmethods/</link>
      <pubDate>Mon, 27 May 2019 22:29:43 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/vue-computed%E5%92%8Cmethods/</guid>
      <description>Vue中computed与methods的区别 computed一个属性，又别的现有属性计算而来 &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;methods&amp;lt;/b&amp;gt;: 就是指函数&amp;lt;/p&amp;gt; 具体来说： computed： computed定义的方法我们是以属性访问的形式调用的，{{computedTest}}，有缓存机制。当computed涉及到变量改变时，computed才会调用 methods 但是methods定义的方法，我们必须要加上()来调用，如{{methodTest</description>
    </item>
    
    <item>
      <title>Js函数</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 25 May 2019 22:36:32 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E5%87%BD%E6%95%B0/</guid>
      <description>JS中，创建函数有三种方法，分别为函数声明和函数表达式，还有Function构造函数（不常见) 函数声明：function XXX（）{……} 函数表达式： var express=function(a1,b1){} ——匿名函数表达式 调用：express(a1,b1) var express=function exps(a1,b1){} ——函数表达式 正确调用 express(a1,b1) 错误调用 exps(a1,b1)，但在函数内部可以调用 解释器在解析JavaScript代码时对于这两种方式并不是一视同仁的。解释器会首先读取函数声明，并使其在执行任何</description>
    </item>
    
    <item>
      <title>JS执行机制</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 15 May 2019 10:18:34 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid>
      <description>JavaScript 执行机制 JavaScript是一种单线程语言。Js任务可以分为同步任务和异步任务。当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。 同步和异步任务分别进入不同的执行&amp;rdquo;场所&amp;rdquo;，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函</description>
    </item>
    
    <item>
      <title>网络模型</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 13 May 2019 11:42:08 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>OSI参考模型与TCP/IP四层模型 TCP/IP为四层，分别为应用层，传输层，网际层和网络接口，是实际应用的 OSI为七层，分别为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。是一种理想条件下的网络模型 TCP和UDP的区别 TCP和UDP都位于传输层，提供一种端到端的服务。 TCP是传输控制协议，是一种可靠地，面向连接的协议。允许两台主机之间无差错的传输。TCP协议还可以进行流量控制，避免</description>
    </item>
    
    <item>
      <title>Hugo笔记</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/hugo%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 10 May 2019 10:18:34 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/hugo%E7%AC%94%E8%AE%B0/</guid>
      <description>h3{ color: lightseagreen; } .codes span{ color: burlywood; } #buzou{ list-style: none; } 利用hugo主题搭建个人主页并上传至github网站 需要做的前期准备 下载好的hugo Git工具 首先，选择好theme后，可以看它对应的使用指南，创建网站。 经常用到的指令： Hugo server %运行 Hugo new XXX.md %XXX可以是中英文 接下来，将搭建好的网站上传至github 第一步：在github中建立新的库。注意，命名必须为xxxxx.github.io 第二步：在本地克隆这个库，使用指令git clone 第三</description>
    </item>
    
    <item>
      <title>TCP握手协议</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/tcp%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 09 May 2019 14:16:43 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/tcp%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/</guid>
      <description>.imges{ width:70%; heigh:70%; display:table-cell; text-align:center; } （1）三次握手 第一次握手：客户端发送syn包到服务器，等待服务器确认。 第二次握手：服务器收到syn包，确认客户端发送的SYN，同时自己发送一个包，即SYN和Ack包 第三次握手：客户端收到服务器的SYN+ack，向服务器发送确认包ack。完成三次握手 （2）四次握手 第一次挥手：主动关闭方发送一个FIN， 第二次挥手：被动方收到FIN包后，发送确认信号ack 第三次挥手：被动方发送FIN，用于关</description>
    </item>
    
    <item>
      <title>HTTP与HTTPS</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/http%E4%B8%8Ehttps/</link>
      <pubDate>Thu, 09 May 2019 13:05:55 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/http%E4%B8%8Ehttps/</guid>
      <description>1）HTTP和HTTPS的基本概念： HTTP：超文本传输协议，属于应用层的协议。 HTTPS：添加了加密及认证机制的HTTP。 2）HTTP与HTTPS的区别 HTTP为明文传播，不安全，端口80 HTTPS为密文传播，设计了SSL协议用于HTTP协议传输的数据进行加密。端口443 3）HTTPS的特点 需要ca证书 秘钥有两个，对称秘钥和非对称秘钥。 对称秘钥用来加密传输数据，非对称秘钥用于加密对称秘钥。 4）H</description>
    </item>
    
  </channel>
</rss>