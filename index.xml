<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yujie Fu</title>
    <link>https://fufulucky.github.io/Fupage.github.io/</link>
    <description>Recent content on Yujie Fu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Mon, 27 May 2019 22:29:43 +0800</lastBuildDate>
    
	<atom:link href="https://fufulucky.github.io/Fupage.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue Computed和methods</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/vue-computed%E5%92%8Cmethods/</link>
      <pubDate>Mon, 27 May 2019 22:29:43 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/vue-computed%E5%92%8Cmethods/</guid>
      <description>Vue中computed与methods的区别 computed一个属性，又别的现有属性计算而来 &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;methods&amp;lt;/b&amp;gt;: 就是指函数&amp;lt;/p&amp;gt; 具体来说： computed： computed定义的方法我们是以属性访问的形式调用的，{{computedTest}}，有缓存机制。当computed涉及到变量改变时，computed才会调用 methods 但是methods定义的方法，我们必须要加上()来调用，如{{methodTest</description>
    </item>
    
    <item>
      <title>Js函数</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 25 May 2019 22:36:32 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E5%87%BD%E6%95%B0/</guid>
      <description>JS中，创建函数有三种方法，分别为函数声明和函数表达式，还有Function构造函数（不常见) 函数声明：function XXX（）{……} 函数表达式： var express=function(a1,b1){} ——匿名函数表达式 调用：express(a1,b1) var express=function exps(a1,b1){} ——函数表达式 正确调用 express(a1,b1) 错误调用 exps(a1,b1)，但在函数内部可以调用 解释器在解析JavaScript代码时对于这两种方式并不是一视同仁的。解释器会首先读取函数声明，并使其在执行任何</description>
    </item>
    
    <item>
      <title>Null，Undefined和NaN的区别</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/nullundefined%E5%92%8Cnan%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 21 May 2019 23:05:28 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/nullundefined%E5%92%8Cnan%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Undefined：当声明了一个变量，但没有进行赋值，那么就是undefined。undefined对应类型undefined，布尔型false，字符串undefined，数字计算结果一定是NaN。 Null：代表“空值”，是一个空对象指针。null对应类型object，布尔值false，数字0，字符串“null”。Typeof null 为 object 什么情况下会返回null document.getElementBy</description>
    </item>
    
    <item>
      <title>JS执行机制</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 15 May 2019 10:18:34 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid>
      <description>JavaScript 执行机制 JavaScript是一种单线程语言。Js任务可以分为同步任务和异步任务。当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。 同步和异步任务分别进入不同的执行&amp;rdquo;场所&amp;rdquo;，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函</description>
    </item>
    
    <item>
      <title>网络模型</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 13 May 2019 11:42:08 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>OSI参考模型与TCP/IP四层模型 TCP/IP为四层，分别为应用层，传输层，网际层和网络接口，是实际应用的 OSI为七层，分别为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。是一种理想条件下的网络模型 TCP和UDP的区别 TCP和UDP都位于传输层，提供一种端到端的服务。 TCP是传输控制协议，是一种可靠地，面向连接的协议。允许两台主机之间无差错的传输。TCP协议还可以进行流量控制，避免</description>
    </item>
    
    <item>
      <title>Hugo笔记</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/hugo%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 10 May 2019 10:18:34 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/hugo%E7%AC%94%E8%AE%B0/</guid>
      <description>h3{ color: lightseagreen; } .codes span{ color: burlywood; } #buzou{ list-style: none; } 利用hugo主题搭建个人主页并上传至github网站 需要做的前期准备 下载好的hugo Git工具 首先，选择好theme后，可以看它对应的使用指南，创建网站。 经常用到的指令： Hugo server %运行 Hugo new XXX.md %XXX可以是中英文 接下来，将搭建好的网站上传至github 第一步：在github中建立新的库。注意，命名必须为xxxxx.github.io 第二步：在本地克隆这个库，使用指令git clone 第三</description>
    </item>
    
    <item>
      <title>Effective Reversible Data Hiding in Encrypted Image with Adaptive Encoding Strategy</title>
      <link>https://fufulucky.github.io/Fupage.github.io/paper/%E7%AC%AC%E4%B8%80%E7%AF%87paper/</link>
      <pubDate>Thu, 09 May 2019 14:40:04 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/paper/%E7%AC%AC%E4%B8%80%E7%AF%87paper/</guid>
      <description>#down{ width:20px; height:20px; } #topic{ color:#33ccff; word-spacing:nowrap; } #topic #T{ color:black; } Effective Reversible Data Hiding in Encrypted Image with Adaptive Encoding Strategy. Fu, Y., Kong, P., Yao, H., Tang, Z., &amp;amp; Qin, C. Information Sciences (2019). Abstract: Recently, reversible data hiding in encrypted image have attracted extensive attentions, which can be applied in secure cloud computing and privacy-preserving image processing. In this paper, a reversible data hiding scheme in encrypted image based on the adaptive encoding strategy is proposed. On the content-owner side, block permutation and stream cipher encryption are applied to mask the contents of original image. Through analyzing the distribution of MSB layers, embeddable blocks are first determined and auxiliary data are then generated by data hider. In order to vacate room for data accommodation, MSB layers of embeddable blocks are adaptively compressed according to occurrence frequency of MSB. Thus, additional data can be embedded into MSB layers of encrypted image together with reversed Huffman codewords and auxiliary data. Based on the availability of encryption key and data-hiding key, the receiver can realize separable operations of data extraction, image decryption and image recovery efficiently. Experimental results demonstrate that, our scheme not only can achieve satisfactory rate-distortion performance,</description>
    </item>
    
    <item>
      <title>TCP握手协议</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/tcp%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 09 May 2019 14:16:43 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/tcp%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/</guid>
      <description>.imges{ width:70%; heigh:70%; display:table-cell; text-align:center; } （1）三次握手 第一次握手：客户端发送syn包到服务器，等待服务器确认。 第二次握手：服务器收到syn包，确认客户端发送的SYN，同时自己发送一个包，即SYN和Ack包 第三次握手：客户端收到服务器的SYN+ack，向服务器发送确认包ack。完成三次握手 （2）四次握手 第一次挥手：主动关闭方发送一个FIN， 第二次挥手：被动方收到FIN包后，发送确认信号ack 第三次挥手：被动方发送FIN，用于关</description>
    </item>
    
    <item>
      <title>HTTP与HTTPS</title>
      <link>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/http%E4%B8%8Ehttps/</link>
      <pubDate>Thu, 09 May 2019 13:05:55 +0800</pubDate>
      
      <guid>https://fufulucky.github.io/Fupage.github.io/blog/2019-05/http%E4%B8%8Ehttps/</guid>
      <description>1）HTTP和HTTPS的基本概念： HTTP：超文本传输协议，属于应用层的协议。 HTTPS：添加了加密及认证机制的HTTP。 2）HTTP与HTTPS的区别 HTTP为明文传播，不安全，端口80 HTTPS为密文传播，设计了SSL协议用于HTTP协议传输的数据进行加密。端口443 3）HTTPS的特点 需要ca证书 秘钥有两个，对称秘钥和非对称秘钥。 对称秘钥用来加密传输数据，非对称秘钥用于加密对称秘钥。 4）H</description>
    </item>
    
  </channel>
</rss>